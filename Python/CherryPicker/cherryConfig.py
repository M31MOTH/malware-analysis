import sys
import re

# Copyright
# =========
# Copyright (C) 2015 Trustwave Holdings, Inc.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>
#
#
# python cherryPicker.py [filename] by Eric Merritt 2015-04-09
#
# =Synopsis
#
# This is a simple python script that decrypts the encoded config files
# for Cherry Picker malware.  It is encoded with a XOR string
#
# Input: filename or none to use the default kb852310.dll filename
#
# Example: python cherryPicker.py
#
# Example: python cherryPicker.py filename.dll
#
# Output: config.bin (decrypted config file)


xor_key = ['0xE6', '0x96', '0x03', '0x00', '0x84', '0x03', '0x01',
           '0x32', '0x4D', '0x36', '0xD0', '0x35', '0x5F', '0x62', '0x65',
           '0x01']


def _ror(val, bits, bit_size):
    return ((val & (2 ** bit_size - 1)) >> bits % bit_size) | \
           (val << (bit_size - (bits % bit_size)) & (2 ** bit_size - 1))

__ROR4__ = lambda val, bits: _ror(val, bits, 32)


def DWORD(list, start):
    i = 0
    result = '0x'
    while i < 4:
        if type(list[start + 3]) == int:
            result = result + format(list[start + 3], '02x')
        else:
            result = result + list[start + 3][2:]
        i = i + 1
        start = start - 1
    return result


def replace_bytes(buffer, start, value):
    i = 4
    indx = 0
    value = re.findall('..', value.split('0x')[1])
    while i > 0:
        buffer[start + indx] = int(value[i-1], 16)
        i = i - 1
        indx = indx + 1


def round_dword(value):
    number = value.split('0x')[1]
    if len(number) > 8:
        number = number[len(number) - 8:len(number)]
    elif len(number) < 8:
        for i in range(0, 8-len(number)):
            number = '0' + number
    return '0x' + number


def decrypt_config(buffer):
    counter = 2208

    while(counter >= 0):
        v2 = 48
        while v2:
            v4 = (v2 & 3) * 4
            xor = int(DWORD(xor_key, v4), 16)
            op1 = int(DWORD(buffer, counter + 4 * ((v2 - 1) & 3)), 16)
            op1 = round_dword(hex(op1 * 2))
            op2 = DWORD(buffer, counter + 4 * ((v2 + 1) & 3))
            newval = int(op1, 16) ^ int(op2, 16)
            value = v2 ^ xor ^ newval
            result = __ROR4__(value,  8)
            v2 = v2 - 1
            result = round_dword(
                hex((result * 9) ^ int(DWORD(buffer, counter + v4), 16)))
            result = round_dword(hex(xor ^ int(result, 16)))

            # Replace the buffer with the new value
            replace_bytes(buffer, counter + v4, result)

        counter = counter - 1
    return buffer

try:
    if len(sys.argv) != 1:
        f = open(sys.argv[1], 'rb')
    else:
        f = open('kb852310.dll', 'rb')
except IOError as e:
    print e
    sys.exit(1)

buff = [ord(i) for i in f.read()]

decrypt_config(buff)

g = open('config.bin', 'wb')
g.write(bytearray(buff))
f.close()
g.close()
