#!/usr/bin/env ruby
#
# Copyright
# =========
# Copyright 2014 - Trustwave Holdings, All rights reserved
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>
#
#
# spark.rb by Eric Merritt 12-08-2014
#
#
# == Requirement
# Utilizes ruby black bag gem by Eric Monti
# 
# https://github.com/emonti/rbkb
#
# == Description
# 	
# This is a simple Ruby script that is designed to decode the network
# traffic sent by Alina POS malware.  This script is designed to work
# on the Spark v1.1 variant
#
# Example: ruby spark.rb "traffic_in_hex
#

require "rbkb"


def parseFile(arr)

	out = File.open("output.txt", "w")

	#malware versioning info
	printf "Malware ver: \tSpark v%d.%d\n", arr[0], arr[1]
	out << "Malware ver:\tSpark v" << arr[0].to_i(16).to_s << "." << arr[1].to_i(16).to_s << "\n"

	#user agent used
	index = arr.index("20")
	uagent = arr[0x2..index].join
	printf "User Agent: \t%s\n", uagent.gsub(/../) { |pair| pair.hex.chr }
	out << "User Agent: \t" << uagent.gsub(/../) { |pair| pair.hex.chr } << "\n"

	#a unique identifier for the infected system
	code = arr[index+2..index+12].join
	index += 15
	printf "Unique Code: \t%s\n", code.gsub(/../) { |pair| pair.hex.chr }
	out << "Unique Code: \t" <<  code.gsub(/../) { |pair| pair.hex.chr } << "\n"

	#types are cards and update
	index2 = index + 6
	fileType = arr[index..index2].join
	printf "Filetype: \t%s\n", fileType.gsub(/../) { |pair| pair.hex.chr }
	out << "Filetype: \t" << fileType.gsub(/../) { |pair| pair.hex.chr } << "\n"
	
	#hostname of the victim machine
	index = index2 + 2
	index2 = arr[index..arr.length].index("00") + index
	hostname = arr[index..index2].join
	printf "Vic Hostname: \t%s\n", hostname.gsub(/../) { |pair| pair.hex.chr }
	out << "Vic Hostname: \t" << hostname.gsub(/../) { |pair| pair.hex.chr } << "\n"
	
	#card or diag(diagnostic?) data
	index = 76
	#should be card or diag
	while not index == arr.length
		index2 = arr[index..arr.length].index("3d") + index
		comType = arr[index..index2-1].join
		printf "command: \t%s => ", comType.gsub(/../) { |pair| pair.hex.chr }
		out << "command: \t=> " << comType.gsub(/../) { |pair| pair.hex.chr } 

		index = index2 + 1
		index2 = arr[index..arr.length].index("26") + index
		com = arr[index..index2-1]
		com = com.join.gsub(/../) { |pair| pair.hex.chr }
		printf "%s\n", com.urldec
		out << com.urldec << "\n"

		index = index2 + 1
	end
	out.close()
end

###############################################
# 					Main					  #
###############################################

if ARGV.include?("-h") or ARGV.include?("-?")
  STDERR.puts "usage: #{File.basename($0)}  [filename]"
  exit 1
elsif fname = ARGV.shift
  dat = File.open(fname, 'rb')
else
  STDERR.puts "usage: #{File.basename($0)}  [filename]"
  exit 1
end

line = Array.new
newLine = Array.new
out = File.open("output.raw", 'wb')

dat.each_char { |i|
	line.push(i.unpack("H2")[0])
}

#Get the key out of the encoded bytes
xorKey = line[0x12..0x23]

#xor the whole thing by 0xAA
line.each_with_index{ |i, index|
	newLine.push(i.unhexify.xor("\xAA").chr.hexify)
}

#running XOR key over the remaining bytes
counter = 0

#decode the other half of the POST
newLine.each_with_index { |val, index|
	#First 76 bytes are header information and are decoded by the above 0xAA XOR key
	if(index > 75)
		newLine[index] = val.unhexify.xor(xorKey[counter % 18].unhexify).chr.hexify
		counter += 1
	end	
}

#write to output.raw
newLine.each{ |i|
	out.write(i.unhexify)
}
out.close

#parse the input 
parseFile(newLine)

puts "\n\nRaw text:\toutput.raw\nFormatted text:\toutput.txt"
